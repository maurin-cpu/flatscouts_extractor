<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlatScouts - Dokumentenergebnisse</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            color: #333;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 300px 350px minmax(300px, 1fr) 4px minmax(300px, 1fr);
            grid-template-rows: 50px 60px 1fr;
            gap: 10px;
            padding: 10px;
            height: 100vh;
        }

        .menu-bar {
            grid-column: 1 / -1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
        }

        .menu-item {
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 6px;
            font-weight: 500;
            transition: all 0.2s;
            color: #495057;
        }

        .menu-item:hover {
            background: #f8f9fa;
            color: #667eea;
        }

        .menu-item.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .content-view {
            grid-column: 1 / -1;
            grid-row: 3;
            display: none;
        }

        .content-view.active {
            display: grid;
            grid-template-columns: 300px 350px minmax(300px, 1fr) 4px minmax(300px, 1fr);
            grid-template-rows: 60px 1fr;
            gap: 10px;
        }

        .header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            padding: 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            font-weight: 600;
            font-size: 14px;
            color: #495057;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            min-height: 0;
            min-width: 0;
        }

        /* Dokumentenliste */
        .document-list {
            list-style: none;
        }

        .document-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .document-item:hover {
            background: #e9ecef;
            transform: translateX(2px);
        }

        .document-item.active {
            background: #667eea;
            color: white;
            border-color: #5568d3;
        }

        .document-item .source {
            font-size: 11px;
            opacity: 0.7;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .document-item .filename {
            font-weight: 500;
            font-size: 13px;
        }

        .document-item .type {
            font-size: 11px;
            margin-top: 4px;
            opacity: 0.8;
        }

        .refresh-btn {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        .refresh-btn:hover {
            background: #5568d3;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }

        .processing-status {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .document-status-item {
            padding: 10px;
            margin-bottom: 8px;
            background: white;
            border-radius: 6px;
            border-left: 4px solid #dee2e6;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .document-status-item.processing {
            border-left-color: #667eea;
            background: #e7f0ff;
        }

        .document-status-item.completed {
            border-left-color: #28a745;
            background: #d4edda;
        }

        .document-status-item.pending {
            border-left-color: #ffc107;
            background: #fff3cd;
        }

        .document-status-item.failed {
            border-left-color: #dc3545;
            background: #f8d7da;
        }

        /* Kategorien-Panel */
        .info-text {
            padding: 15px;
            color: #6c757d;
            font-style: italic;
            text-align: center;
        }

        .category-group {
            margin-bottom: 15px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            overflow: hidden;
        }

        .category-header {
            padding: 12px;
            background: #f8f9fa;
            font-weight: 600;
            font-size: 13px;
            color: #495057;
            border-bottom: 1px solid #e9ecef;
        }

        .category-content {
            padding: 10px;
        }

        .page-radio {
            display: block;
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .page-radio:hover {
            background: #f8f9fa;
        }

        .page-radio input[type="radio"] {
            margin-right: 8px;
        }

        .page-radio.selected {
            background: #667eea;
            color: white;
        }

        .extracted-data {
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 12px;
        }

        .extracted-data-item {
            padding: 4px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .extracted-data-item:last-child {
            border-bottom: none;
        }

        /* PDF-Viewer */
        .pdf-controls {
            padding: 10px 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .pdf-controls button {
            padding: 6px 12px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .pdf-controls button:hover {
            background: #f8f9fa;
            border-color: #667eea;
        }

        .pdf-controls .page-info {
            margin-left: auto;
            font-size: 12px;
            color: #6c757d;
        }

        .pdf-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            background: #525252;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            min-height: 0;
            min-width: 0;
        }

        .pdf-viewer {
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 100%;
            height: auto;
        }

        .error-message {
            padding: 20px;
            color: #dc3545;
            text-align: center;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #6c757d;
        }

        /* Resize Handle */
        .resize-handle {
            width: 100%;
            background: #dee2e6;
            cursor: col-resize;
            position: relative;
            z-index: 10;
            transition: background 0.2s;
            margin: 0;
        }

        .resize-handle:hover {
            background: #667eea;
        }

        .resize-handle.active {
            background: #667eea;
        }

        /* JSON-Anzeige */
        .json-viewer {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            height: 100%;
            overflow-y: auto;
            box-sizing: border-box;
        }

        .json-key {
            color: #9cdcfe;
        }

        .json-string {
            color: #ce9178;
        }

        .json-number {
            color: #b5cea8;
        }

        .json-boolean {
            color: #569cd6;
        }

        .json-null {
            color: #569cd6;
        }

        /* Markdown-Anzeige */
        .markdown-viewer {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            font-size: 14px;
            line-height: 1.6;
            color: #212529;
            background: white;
            padding: 15px;
            overflow-y: auto;
            height: 100%;
        }

        .markdown-viewer h1 {
            font-size: 24px;
            font-weight: 600;
            margin-top: 24px;
            margin-bottom: 16px;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 8px;
        }

        .markdown-viewer h2 {
            font-size: 20px;
            font-weight: 600;
            margin-top: 20px;
            margin-bottom: 12px;
        }

        .markdown-viewer h3 {
            font-size: 16px;
            font-weight: 600;
            margin-top: 16px;
            margin-bottom: 8px;
        }

        .markdown-viewer table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
        }

        .markdown-viewer table th,
        .markdown-viewer table td {
            border: 1px solid #dee2e6;
            padding: 8px 12px;
            text-align: left;
        }

        .markdown-viewer table th {
            background-color: #f8f9fa;
            font-weight: 600;
        }

        .markdown-viewer p {
            margin: 8px 0;
        }

        .markdown-viewer ul,
        .markdown-viewer ol {
            margin: 8px 0;
            padding-left: 24px;
        }

        .markdown-viewer code {
            background-color: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .markdown-viewer pre {
            background-color: #f8f9fa;
            padding: 12px;
            border-radius: 4px;
            overflow-x: auto;
        }

        .markdown-viewer blockquote {
            border-left: 4px solid #667eea;
            padding-left: 16px;
            margin: 16px 0;
            color: #6c757d;
        }

        .markdown-viewer hr {
            border: none;
            border-top: 2px solid #e9ecef;
            margin: 24px 0;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Men√ºband -->
        <div class="menu-bar">
            <div class="menu-item" onclick="showView('upload')">üì§ Upload</div>
            <div class="menu-item active" onclick="showView('classification')">üìä Klassifizierung</div>
        </div>

        <!-- Klassifizierungs-Ansicht -->
        <div id="classificationView" class="content-view active">
            <div class="header">
                <h1>üìÑ FlatScouts - Dokumentenergebnisse</h1>
            </div>

        <!-- Linke Spalte: Dokumentenliste -->
        <div class="panel" style="grid-column: 1; grid-row: 2;">
            <div class="panel-header">Verarbeitete Dokumente</div>
            <div class="panel-content">
                <ul class="document-list" id="documentList">
                    <li class="loading">Lade Dokumente...</li>
                </ul>
                <button class="refresh-btn" onclick="processDocuments()" style="width: 100%; margin-top: 10px;">üìä Dokumente Verarbeiten</button>
                
                <div id="processingStatus" class="processing-status" style="display: none; margin-top: 15px;">
                    <h4 style="margin-bottom: 10px; color: #495057; font-size: 14px;">üîÑ Verarbeitungsstatus:</h4>
                    <div id="processingStatusContent"></div>
                </div>
            </div>
        </div>

        <!-- Mittlere Spalte: Kategorien & Seiten -->
        <div class="panel" style="grid-column: 2; grid-row: 2;">
            <div class="panel-header">Kategorien & Seiten</div>
            <div class="panel-content" id="categoriesContent">
                <div class="info-text">W√§hlen Sie ein Dokument aus der Liste</div>
                <button class="refresh-btn" onclick="parseDocuments()" style="width: 100%; margin-top: 15px; background: #28a745;">üìù Dokumente Parsen</button>
            </div>
        </div>

        <!-- Rechte Spalte: PDF-Viewer -->
        <div class="panel" id="pdfPanel" style="grid-column: 3; grid-row: 2;">
            <div class="panel-header">PDF-Viewer</div>
            <div class="pdf-controls">
                <span class="page-info" id="pageInfo">Seite: - / -</span>
                <button onclick="prevPage()">‚óÄ Vorherige</button>
                <button onclick="nextPage()">N√§chste ‚ñ∂</button>
                <button onclick="zoomOut()">‚àí</button>
                <button onclick="zoomIn()">+</button>
            </div>
            <div class="pdf-container" id="pdfContainer">
                <div class="info-text">W√§hlen Sie ein Dokument aus</div>
            </div>
        </div>

        <!-- Resize Handle zwischen PDF und JSON -->
        <div class="resize-handle" id="resizeHandle" style="grid-column: 4; grid-row: 2;"></div>

        <!-- JSON/Markdown-Anzeige rechts -->
        <div class="panel" id="jsonPanel" style="grid-column: 5; grid-row: 2;">
            <div class="panel-header">
                <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 8px;">
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <select id="jsonSourceSelect" onchange="changeJSONSource()" style="padding: 4px 8px; font-size: 12px; border: 1px solid #dee2e6; border-radius: 4px; background: white; color: #495057; cursor: pointer;">
                            <option value="split_results">‚úÇÔ∏è Split Results</option>
                            <option value="parsed_segments">üìù Parsed Segments</option>
                        </select>
                        <select id="viewModeSelect" onchange="changeViewMode()" style="padding: 4px 8px; font-size: 12px; border: 1px solid #dee2e6; border-radius: 4px; background: white; color: #495057; cursor: pointer; display: none;">
                            <option value="json">üìÑ JSON</option>
                            <option value="markdown">üìù Markdown</option>
                        </select>
                    </div>
                    <button id="jsonFilterBtn" onclick="toggleJSONFilter()" style="padding: 4px 10px; font-size: 11px; border: 1px solid #dee2e6; border-radius: 4px; background: white; color: #495057; cursor: pointer; display: none;">
                        üìÑ Nur Segment
                    </button>
                </div>
            </div>
            <div class="panel-content" id="jsonContent" style="padding: 0; display: flex; flex-direction: column; min-height: 0;">
                <div class="info-text" style="flex: 0 0 auto;">Lade Daten...</div>
            </div>
        </div>
        </div>
        <!-- Ende Klassifizierungs-Ansicht -->

        <!-- Upload-Ansicht -->
        <div id="uploadView" class="content-view">
            <div class="header" style="grid-column: 1 / -1; grid-row: 1;">
                <h1>üì§ Dokumente hochladen</h1>
            </div>
            <div class="panel" style="grid-column: 1 / -1; grid-row: 2;">
                <div class="panel-header">Dateien hochladen</div>
                <div class="panel-content" style="padding: 30px; overflow-y: auto;">
                    <div id="uploadArea" style="border: 3px dashed #667eea; border-radius: 12px; padding: 60px; text-align: center; background: #f8f9fa; transition: all 0.3s; cursor: pointer;" 
                         ondrop="handleDrop(event)" 
                         ondragover="handleDragOver(event)" 
                         ondragleave="handleDragLeave(event)"
                         onclick="document.getElementById('fileInput').click()">
                        <div style="font-size: 48px; margin-bottom: 20px;">üìÑ</div>
                        <h2 style="color: #667eea; margin-bottom: 10px;">Dateien hier ablegen</h2>
                        <p style="color: #6c757d; margin-bottom: 20px;">oder klicken Sie, um Dateien auszuw√§hlen</p>
                        <p style="color: #999; font-size: 14px;">Unterst√ºtzte Formate: PDF</p>
                        <input type="file" id="fileInput" multiple accept=".pdf,.PDF" style="display: none;" onchange="handleFileSelect(event)">
                    </div>
                    <div id="uploadProgress" style="margin-top: 30px; display: none;">
                        <h3 style="margin-bottom: 15px;">Upload-Status:</h3>
                        <div id="uploadList"></div>
                    </div>
                    <div id="uploadSuccess" style="margin-top: 20px; display: none;">
                        <div style="background: #d4edda; border: 1px solid #c3e6cb; color: #155724; padding: 15px; border-radius: 8px;">
                            ‚úÖ Dateien erfolgreich hochgeladen!
                        </div>
                    </div>
                    
                    <div id="filesList" style="margin-top: 40px; display: none;">
                        <h3 style="margin-bottom: 15px; color: #495057;">üìÅ Hochgeladene Dokumente:</h3>
                        <div id="filesListContent" style="background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; max-height: 60vh; overflow-y: auto; overflow-x: hidden; min-height: 200px;">
                            <div class="info-text">Noch keine Dokumente hochgeladen</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Ende Upload-Ansicht -->
    </div>

    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <script>
        // PDF.js Worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let documents = [];
        let currentDocument = null;
        let currentPdfDoc = null;
        let currentPageNum = 1;
        let zoomLevel = 1.0;
        let currentSegmentPages = [];
        let currentSegmentIndex = 0;
        let isRenderingSegment = false;
        let currentSegmentName = null;
        let currentSegmentCategory = null;
        let splitResultsJSON = null;
        let parsedSegmentsJSON = null;
        let showOnlySegment = false;
        let currentJSONSource = 'split_results';
        let currentViewMode = 'json';

        // Lade Dokumente beim Start
        loadDocuments();
        // Lade Split Results JSON beim Start
        loadSplitResultsJSON();
        // Lade Parsed Segments JSON beim Start
        loadParsedSegmentsJSON();
        
        // Dateiliste startet leer und wird nur nach Upload angezeigt
        
        // Initialisiere JSON-Anzeige
        setTimeout(() => {
            if (splitResultsJSON) {
                renderJSONContent();
            }
        }, 500);

        async function loadDocuments() {
            const list = document.getElementById('documentList');
            list.innerHTML = '<li class="loading">üîÑ Aktualisiere Dokumente...</li>';
            
            try {
                // Lade Dokumente neu (mit Cache-Busting)
                const response = await fetch('/api/documents?' + new Date().getTime(), {
                    cache: 'no-store',
                    headers: {
                        'Cache-Control': 'no-cache'
                    }
                });
                documents = await response.json();
                
                // Lade auch JSON-Daten neu
                await loadSplitResultsJSON();
                await loadParsedSegmentsJSON();
                
                // Reset aktuelles Dokument falls es nicht mehr existiert
                if (currentDocument) {
                    const stillExists = documents.some(doc => 
                        doc.datei === currentDocument.datei && doc.quelle === currentDocument.quelle
                    );
                    if (!stillExists) {
                        currentDocument = null;
                        currentSegmentPages = [];
                        currentSegmentIndex = 0;
                        currentSegmentName = null;
                        currentSegmentCategory = null;
                        // Leere PDF-Viewer
                        const pdfViewer = document.getElementById('pdfViewer');
                        if (pdfViewer) {
                            pdfViewer.innerHTML = '';
                        }
                        // Leere Kategorien-Anzeige
                        const categoriesContent = document.getElementById('categoriesContent');
                        if (categoriesContent) {
                            categoriesContent.innerHTML = '<div class="info-text">W√§hlen Sie ein Dokument aus der Liste</div>';
                        }
                        // Verstecke Filter-Button
                        const filterBtn = document.getElementById('jsonFilterBtn');
                        if (filterBtn) {
                            filterBtn.style.display = 'none';
                        }
                        const viewModeSelect = document.getElementById('viewModeSelect');
                        if (viewModeSelect) {
                            viewModeSelect.style.display = 'none';
                        }
                        showOnlySegment = false;
                    }
                }
                
                renderDocumentList();
                
                // Aktualisiere JSON-Anzeige falls Dokument noch existiert
                if (currentDocument && splitResultsJSON) {
                    updateContentDisplay();
                } else if (splitResultsJSON) {
                    renderJSONContent();
                }
            } catch (error) {
                console.error('Fehler beim Laden der Dokumente:', error);
                list.innerHTML = '<li class="error-message">Fehler beim Laden der Dokumente</li>';
            }
        }

        function renderDocumentList() {
            const list = document.getElementById('documentList');
            list.innerHTML = '';

            if (documents.length === 0) {
                list.innerHTML = '<li class="info-text">Keine Ergebnisse gefunden</li>';
                return;
            }

            documents.forEach((doc, index) => {
                const li = document.createElement('li');
                li.className = 'document-item';
                li.onclick = () => selectDocument(index);

                const source = document.createElement('div');
                source.className = 'source';
                source.textContent = doc.quelle;

                const filename = document.createElement('div');
                filename.className = 'filename';
                filename.textContent = doc.datei;

                if (doc.quelle === 'LlamaParse' && doc.daten.typ) {
                    const type = document.createElement('div');
                    type.className = 'type';
                    type.textContent = `Typ: ${doc.daten.typ}`;
                    li.appendChild(source);
                    li.appendChild(filename);
                    li.appendChild(type);
                } else {
                    li.appendChild(source);
                    li.appendChild(filename);
                }

                list.appendChild(li);
            });
        }

        function selectDocument(index) {
            // Aktiviere visuell das ausgew√§hlte Element
            document.querySelectorAll('.document-item').forEach((item, i) => {
                if (i === index) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });

            currentDocument = documents[index];
            renderCategories();
            // Reset Segment-Navigation - stoppe alle Renderings
            currentSegmentPages = [];
            currentSegmentIndex = 0;
            currentSegmentName = null;
            currentSegmentCategory = null;
            isRenderingSegment = false;
            isRendering = false;
            clearTimeout(resizeTimeout);
            // Verstecke Filter-Button wenn kein Segment ausgew√§hlt
            const filterBtn = document.getElementById('jsonFilterBtn');
            if (filterBtn) {
                filterBtn.style.display = 'none';
            }
            showOnlySegment = false;
            // Zeige wieder vollst√§ndiges JSON
            if (splitResultsJSON) {
                renderJSONContent();
            }
            loadPDF(currentDocument.datei);
        }

        function renderCategories() {
            const content = document.getElementById('categoriesContent');
            content.innerHTML = '';

            if (!currentDocument) {
                content.innerHTML = '<div class="info-text">W√§hlen Sie ein Dokument aus der Liste</div>';
                return;
            }

            const quelle = currentDocument.quelle;
            const daten = currentDocument.daten;
            
            console.log('renderCategories called - quelle:', quelle, 'daten:', daten);

            // Header
            const header = document.createElement('div');
            header.className = 'info-text';
            header.textContent = `${quelle}: ${currentDocument.datei}`;
            content.appendChild(header);

            // Unterst√ºtze verschiedene Quellen
            if (quelle === 'Split-API' || quelle === 'Split-Results') {
                renderSplitCategories(daten, content);
            } else if (quelle === 'Parsed-Segments') {
                // parsed_segments.json hat die gleiche Struktur wie split_results.json
                renderSplitCategories(daten, content);
            } else if (quelle === 'LlamaParse') {
                renderMainCategories(daten, content);
            } else {
                // Fallback: Versuche Split-Kategorien zu rendern
                if (daten.segments) {
                    renderSplitCategories(daten, content);
                } else {
                    content.innerHTML += '<div class="info-text">Unbekannte Datenstruktur</div>';
                }
            }
        }

        function renderSplitCategories(daten, container) {
            console.log('renderSplitCategories called with:', daten);
            
            if (!daten) {
                const error = document.createElement('div');
                error.className = 'error-message';
                error.textContent = 'Keine Daten vorhanden';
                container.appendChild(error);
                return;
            }
            
            if (daten.fehler) {
                const error = document.createElement('div');
                error.className = 'error-message';
                error.textContent = `Fehler: ${daten.fehler}`;
                container.appendChild(error);
                return;
            }

            // Unterst√ºtze beide Datenstrukturen:
            // 1. Neue Struktur: daten.segments (direkt aus JSON)
            // 2. Alte Struktur: daten.ergebnis.result.segments (von API)
            let segments = [];
            
            if (daten.segments && Array.isArray(daten.segments)) {
                // Neue Struktur: Segmente direkt verf√ºgbar
                segments = daten.segments;
                console.log('Segmente gefunden (neue Struktur):', segments.length);
            } else {
                // Alte Struktur: Von API-Ergebnis
                const ergebnis = daten.ergebnis || {};
                const status = ergebnis.status;

                if (status === 'failed') {
                    const error = document.createElement('div');
                    error.className = 'error-message';
                    error.textContent = 'Verarbeitung fehlgeschlagen';
                    container.appendChild(error);
                    return;
                }

                segments = ergebnis.result?.segments || [];
                console.log('Segmente gefunden (alte Struktur):', segments.length);
            }
            
            if (segments.length === 0) {
                console.log('Keine Segmente gefunden, daten:', daten);
                container.innerHTML += '<div class="info-text">Keine Segmente gefunden</div>';
                return;
            }

            // Gruppiere nach Kategorie
            const kategorienDict = {};
            segments.forEach(segment => {
                const kategorie = segment.category || 'Unbekannt';
                if (!kategorienDict[kategorie]) {
                    kategorienDict[kategorie] = [];
                }
                kategorienDict[kategorie].push(segment);
            });

            Object.keys(kategorienDict).forEach(kategorie => {
                const segListe = kategorienDict[kategorie];

                if (segListe.length > 0) {
                    const group = document.createElement('div');
                    group.className = 'category-group';

                    const header = document.createElement('div');
                    header.className = 'category-header';
                    header.textContent = `${kategorie} (${segListe.length} Segment${segListe.length > 1 ? 'e' : ''})`;
                    group.appendChild(header);

                    const content = document.createElement('div');
                    content.className = 'category-content';

                    // Zeige jedes Segment einzeln an
                    segListe.forEach((segment, index) => {
                        const segmentName = segment.name || `${kategorie}_${index + 1}`;
                        const pages = segment.pages || [];
                        const confidence = segment.confidence_category || 'unknown';
                        
                        // Parse Seiten
                        let seitenArray = [];
                        if (Array.isArray(pages)) {
                            seitenArray = pages.map(p => typeof p === 'number' ? p : parseInt(p)).filter(p => !isNaN(p));
                        } else if (typeof pages === 'string') {
                            seitenArray = pages.split(/\s+/).map(p => parseInt(p)).filter(p => !isNaN(p));
                        }
                        
                        if (seitenArray.length > 0) {
                            const segmentBtn = document.createElement('button');
                            segmentBtn.className = 'segment-button';
                            segmentBtn.style.width = '100%';
                            segmentBtn.style.padding = '10px';
                            segmentBtn.style.marginBottom = '8px';
                            segmentBtn.style.textAlign = 'left';
                            segmentBtn.style.borderRadius = '6px';
                            segmentBtn.style.cursor = 'pointer';
                            segmentBtn.style.transition = 'all 0.2s';
                            segmentBtn.style.fontWeight = '500';
                            segmentBtn.style.position = 'relative';
                            
                            // Bestimme Farben basierend auf Konfidenz
                            let bgColor, borderColor, confidenceColor, confidenceText;
                            switch(confidence.toLowerCase()) {
                                case 'high':
                                    bgColor = '#e8f5e9';
                                    borderColor = '#4caf50';
                                    confidenceColor = '#2e7d32';
                                    confidenceText = 'Hoch';
                                    break;
                                case 'medium':
                                    bgColor = '#fff3e0';
                                    borderColor = '#ff9800';
                                    confidenceColor = '#e65100';
                                    confidenceText = 'Mittel';
                                    break;
                                case 'low':
                                    bgColor = '#ffebee';
                                    borderColor = '#f44336';
                                    confidenceColor = '#c62828';
                                    confidenceText = 'Niedrig';
                                    break;
                                default:
                                    bgColor = '#f5f5f5';
                                    borderColor = '#9e9e9e';
                                    confidenceColor = '#616161';
                                    confidenceText = 'Unbekannt';
                            }
                            
                            segmentBtn.style.background = bgColor;
                            segmentBtn.style.border = `2px solid ${borderColor}`;
                            
                            // Header mit Segment-Name und Konfidenz-Badge
                            const headerRow = document.createElement('div');
                            headerRow.style.display = 'flex';
                            headerRow.style.justifyContent = 'space-between';
                            headerRow.style.alignItems = 'center';
                            headerRow.style.marginBottom = '6px';
                            
                            const segmentTitle = document.createElement('div');
                            segmentTitle.style.fontSize = '13px';
                            segmentTitle.style.fontWeight = '600';
                            segmentTitle.textContent = segmentName;
                            
                            const confidenceBadge = document.createElement('div');
                            confidenceBadge.style.padding = '2px 8px';
                            confidenceBadge.style.borderRadius = '12px';
                            confidenceBadge.style.fontSize = '10px';
                            confidenceBadge.style.fontWeight = '600';
                            confidenceBadge.style.background = borderColor;
                            confidenceBadge.style.color = 'white';
                            confidenceBadge.textContent = `‚úì ${confidenceText}`;
                            
                            headerRow.appendChild(segmentTitle);
                            headerRow.appendChild(confidenceBadge);
                            
                            const segmentPages = document.createElement('div');
                            segmentPages.style.fontSize = '11px';
                            segmentPages.style.color = '#6c757d';
                            segmentPages.textContent = `Seiten: ${seitenArray.join(', ')}`;
                            
                            segmentBtn.appendChild(headerRow);
                            segmentBtn.appendChild(segmentPages);
                            
                            const segmentCategory = segment.category || kategorie;
                            segmentBtn.onclick = () => showSegmentPages(seitenArray, segmentName, segmentCategory);
                            segmentBtn.onmouseover = function() {
                                this.style.transform = 'translateY(-2px)';
                                this.style.boxShadow = '0 4px 8px rgba(0,0,0,0.15)';
                            };
                            segmentBtn.onmouseout = function() {
                                this.style.transform = 'translateY(0)';
                                this.style.boxShadow = 'none';
                            };
                            
                            content.appendChild(segmentBtn);
                        }
                    });

                    group.appendChild(content);
                    container.appendChild(group);
                }
            });
        }

        function renderMainCategories(daten, container) {
            const typ = daten.typ || 'Unbekannt';
            const seitenNummern = daten.seiten_nummern || [];
            const extrahiertDaten = daten.extrahiert_daten || {};

            // Typ-Anzeige
            const typLabel = document.createElement('div');
            typLabel.className = 'category-header';
            typLabel.textContent = `Typ: ${typ}`;
            container.appendChild(typLabel);

            if (seitenNummern.length > 0) {
                const group = document.createElement('div');
                group.className = 'category-group';

                const header = document.createElement('div');
                header.className = 'category-header';
                header.textContent = `Seiten (${seitenNummern.length} Seiten)`;
                group.appendChild(header);

                const content = document.createElement('div');
                content.className = 'category-content';

                seitenNummern.forEach(seite => {
                    const radio = document.createElement('label');
                    radio.className = 'page-radio';
                    radio.innerHTML = `<input type="radio" name="page" value="${seite}" onchange="goToPage(${seite})"> Seite ${seite}`;
                    content.appendChild(radio);
                });

                group.appendChild(content);
                container.appendChild(group);
            }

            // Extrahiert Daten
            if (Object.keys(extrahiertDaten).length > 0) {
                const dataDiv = document.createElement('div');
                dataDiv.className = 'extracted-data';
                const dataHeader = document.createElement('div');
                dataHeader.className = 'category-header';
                dataHeader.textContent = 'Extrahiert Daten';
                dataDiv.appendChild(dataHeader);

                Object.entries(extrahiertDaten).forEach(([key, value]) => {
                    const item = document.createElement('div');
                    item.className = 'extracted-data-item';
                    if (typeof value === 'boolean') {
                        item.textContent = `${value ? '‚úì' : '‚úó'} ${key}: ${value}`;
                    } else {
                        item.textContent = `‚Ä¢ ${key}: ${value}`;
                    }
                    dataDiv.appendChild(item);
                });

                container.appendChild(dataDiv);
            }
        }

        async function loadPDF(filename) {
            const container = document.getElementById('pdfContainer');
            container.innerHTML = '<div class="loading">Lade PDF...</div>';

            try {
                const url = `/api/pdf/${encodeURIComponent(filename)}`;
                const loadingTask = pdfjsLib.getDocument(url);
                currentPdfDoc = await loadingTask.promise;
                currentPageNum = 1;
                renderPage();
            } catch (error) {
                console.error('Fehler beim Laden des PDFs:', error);
                container.innerHTML = `<div class="error-message">Fehler beim Laden des PDFs: ${error.message}</div>`;
                currentPdfDoc = null;
            }
        }

        async function renderPage() {
            if (!currentPdfDoc || isRenderingSegment) return Promise.resolve();

            const container = document.getElementById('pdfContainer');
            if (!container) return Promise.resolve();
            
            // Wenn ein Segment aktiv ist, zeige alle Seiten des Segments
            if (currentSegmentPages.length > 0 && !isRenderingSegment) {
                await renderSegmentPages();
                return;
            }
            
            // Standard: Zeige nur eine Seite
            container.style.display = 'flex';
            container.style.justifyContent = 'center';
            container.style.alignItems = 'flex-start';
            
            const page = await currentPdfDoc.getPage(currentPageNum);
            
            // Berechne optimale Skalierung basierend auf Container-Gr√∂√üe
            const containerWidth = container.clientWidth - 40; // Padding ber√ºcksichtigen
            const containerHeight = container.clientHeight - 40;
            
            // Verhindere Rendering bei zu kleinen Containern
            if (containerWidth < 50 || containerHeight < 50) {
                return Promise.resolve();
            }
            
            const viewport = page.getViewport({ scale: 1.0 });
            const scaleX = containerWidth / viewport.width;
            const scaleY = containerHeight / viewport.height;
            const scale = Math.min(scaleX, scaleY, zoomLevel); // Verwende den kleineren Wert
            
            const scaledViewport = page.getViewport({ scale: scale });

            const canvas = document.createElement('canvas');
            canvas.className = 'pdf-viewer';
            const context = canvas.getContext('2d');
            canvas.height = scaledViewport.height;
            canvas.width = scaledViewport.width;

            await page.render({
                canvasContext: context,
                viewport: scaledViewport
            }).promise;

            container.innerHTML = '';
            container.appendChild(canvas);

            // Aktualisiere Seitenanzeige
            const pageInfo = document.getElementById('pageInfo');
            if (pageInfo) {
                pageInfo.textContent = `Seite: ${currentPageNum} / ${currentPdfDoc.numPages}`;
            }
        }

        async function renderSegmentPages() {
            if (!currentPdfDoc || currentSegmentPages.length === 0) {
                return Promise.resolve();
            }

            // Verhindere mehrfache Aufrufe
            if (isRenderingSegment) {
                return Promise.resolve();
            }

            isRenderingSegment = true;
            const container = document.getElementById('pdfContainer');
            if (!container) {
                isRenderingSegment = false;
                return Promise.resolve();
            }
            
            // Stoppe ALLE laufenden Renderings und Prozesse
            clearTimeout(resizeTimeout);
            isRendering = false;
            
            // Pausiere ResizeObserver tempor√§r
            pauseResizeObserver();
            
            container.innerHTML = '<div class="loading">Lade Segment-Seiten...</div>';
            
            try {
                // Erstelle Container f√ºr alle Seiten
                const pagesContainer = document.createElement('div');
                pagesContainer.style.display = 'flex';
                pagesContainer.style.flexDirection = 'column';
                pagesContainer.style.alignItems = 'center';
                pagesContainer.style.gap = '20px';
                pagesContainer.style.padding = '20px';
                pagesContainer.style.width = '100%';
                
                // Berechne optimale Skalierung basierend auf Container-Gr√∂√üe
                const containerWidth = Math.max(container.clientWidth - 40, 300);
                
                // Lade und rendere alle Seiten des Segments
                for (let i = 0; i < currentSegmentPages.length; i++) {
                    const pageNum = currentSegmentPages[i];
                    try {
                        const page = await currentPdfDoc.getPage(pageNum);
                        
                        const viewport = page.getViewport({ scale: 1.0 });
                        const scaleX = containerWidth / viewport.width;
                        const scale = Math.min(scaleX, zoomLevel);
                        
                        const scaledViewport = page.getViewport({ scale: scale });
                        
                        const canvas = document.createElement('canvas');
                        canvas.className = 'pdf-viewer';
                        canvas.style.marginBottom = '10px';
                        canvas.style.display = 'block';
                        const context = canvas.getContext('2d');
                        canvas.height = scaledViewport.height;
                        canvas.width = scaledViewport.width;
                        
                        await page.render({
                            canvasContext: context,
                            viewport: scaledViewport
                        }).promise;
                        
                        // F√ºge Seitenlabel hinzu
                        const pageWrapper = document.createElement('div');
                        pageWrapper.style.display = 'flex';
                        pageWrapper.style.flexDirection = 'column';
                        pageWrapper.style.alignItems = 'center';
                        pageWrapper.style.marginBottom = '20px';
                        pageWrapper.style.width = '100%';
                        
                        const pageLabel = document.createElement('div');
                        pageLabel.style.padding = '8px 16px';
                        pageLabel.style.background = '#667eea';
                        pageLabel.style.color = 'white';
                        pageLabel.style.borderRadius = '4px';
                        pageLabel.style.marginBottom = '10px';
                        pageLabel.style.fontSize = '12px';
                        pageLabel.style.fontWeight = '500';
                        pageLabel.textContent = `Seite ${pageNum}`;
                        
                        pageWrapper.appendChild(pageLabel);
                        pageWrapper.appendChild(canvas);
                        pagesContainer.appendChild(pageWrapper);
                    } catch (error) {
                        console.error(`Fehler beim Laden von Seite ${pageNum}:`, error);
                    }
                }
                
                // Setze Container-Inhalt komplett neu
                container.innerHTML = '';
                // Wichtig: Setze Display zur√ºck auf flex f√ºr normale Ansicht, aber overflow f√ºr Scrollen
                container.style.display = 'block';
                container.style.overflowY = 'auto';
                container.style.overflowX = 'hidden';
                container.style.height = '100%';
                container.appendChild(pagesContainer);
                
                // Scroll zum Anfang nach kurzer Verz√∂gerung, damit DOM aktualisiert ist
                setTimeout(() => {
                    container.scrollTop = 0;
                }, 100);
                
                // Aktualisiere Seitenanzeige
                const pageInfo = document.getElementById('pageInfo');
                if (pageInfo && currentSegmentPages.length > 0) {
                    const segmentName = pageInfo.textContent.split(':')[0] || 'Segment';
                    pageInfo.textContent = `${segmentName}: ${currentSegmentPages.length} Seite${currentSegmentPages.length > 1 ? 'n' : ''} (${currentSegmentPages.join(', ')})`;
                }
            } catch (error) {
                console.error('Fehler beim Rendern der Segment-Seiten:', error);
                container.innerHTML = `<div class="error-message">Fehler beim Laden: ${error.message}</div>`;
            } finally {
                isRenderingSegment = false;
                // Setze ResizeObserver wieder aktiv
                resumeResizeObserver();
            }
        }

        // Resize-Handler f√ºr dynamische Anpassung - optimiert f√ºr fl√ºssige Updates
        let resizeTimeout;
        let isRendering = false;
        
        function scheduleRender() {
            if (isRendering || isRenderingSegment) return;
            
            clearTimeout(resizeTimeout);
            resizeTimeout = requestAnimationFrame(() => {
                if (currentPdfDoc && !isRendering && !isRenderingSegment) {
                    isRendering = true;
                    renderPage().then(() => {
                        isRendering = false;
                    }).catch(() => {
                        isRendering = false;
                    });
                }
            });
        }
        
        window.addEventListener('resize', scheduleRender);

        function prevPage() {
            if (!currentPdfDoc) return;
            
            // Wenn ein Segment aktiv ist, scroll zum Anfang
            if (currentSegmentPages.length > 0) {
                const container = document.getElementById('pdfContainer');
                if (container) {
                    container.scrollTo({ top: 0, behavior: 'smooth' });
                }
                return;
            }
            
            // Standard-Navigation
            if (currentPageNum > 1) {
                currentPageNum--;
                renderPage();
            }
        }

        function nextPage() {
            if (!currentPdfDoc) return;
            
            // Wenn ein Segment aktiv ist, scroll zum Ende
            if (currentSegmentPages.length > 0) {
                const container = document.getElementById('pdfContainer');
                if (container) {
                    container.scrollTo({ top: container.scrollHeight, behavior: 'smooth' });
                }
                return;
            }
            
            // Standard-Navigation
            if (currentPageNum < currentPdfDoc.numPages) {
                currentPageNum++;
                renderPage();
            }
        }

        function zoomIn() {
            zoomLevel = Math.min(zoomLevel + 0.2, 3.0);
            if (currentPdfDoc) renderPage();
        }

        function zoomOut() {
            zoomLevel = Math.max(zoomLevel - 0.2, 0.5);
            if (currentPdfDoc) renderPage();
        }

        function showSegmentPages(pages, segmentName, segmentCategory) {
            if (!currentPdfDoc || pages.length === 0) return;
            
            // Stoppe alle laufenden Prozesse
            clearTimeout(resizeTimeout);
            isRendering = false;
            
            // Verhindere mehrfache Aufrufe w√§hrend des Renderings
            if (isRenderingSegment) {
                console.log('Segment wird bereits geladen, ignoriere Klick');
                return;
            }
            
            // Setze Segment-Pages und Name
            currentSegmentPages = pages.sort((a, b) => a - b);
            currentSegmentIndex = 0;
            currentSegmentName = segmentName;
            currentSegmentCategory = segmentCategory;
            
            // Zeige Filter-Button und View-Mode Select wenn Segment ausgew√§hlt
            const filterBtn = document.getElementById('jsonFilterBtn');
            const viewModeSelect = document.getElementById('viewModeSelect');
            if (filterBtn) {
                filterBtn.style.display = 'block';
                filterBtn.textContent = showOnlySegment ? 'üìÑ Gesamtes JSON' : 'üìÑ Nur Segment';
            }
            if (viewModeSelect) {
                viewModeSelect.style.display = 'block';
            }
            
            // Aktualisiere PDF-Controls mit Segment-Navigation
            updatePDFControlsForSegment(segmentName, currentSegmentPages);
            
            // Aktualisiere Anzeige basierend auf aktueller Quelle und Modus
            updateContentDisplay();
            
            // Zeige alle Seiten des Segments direkt (nicht √ºber renderPage)
            renderSegmentPages();
        }

        function updatePDFControlsForSegment(segmentName, pages) {
            const pageInfo = document.getElementById('pageInfo');
            if (pageInfo && pages.length > 0) {
                const currentIndex = pages.indexOf(currentPageNum);
                pageInfo.textContent = `${segmentName}: Seite ${currentPageNum} (${currentIndex + 1}/${pages.length})`;
            }
        }

        function goToPage(pageNum) {
            if (currentPdfDoc) {
                currentPageNum = pageNum;
                renderPage();
                
                // Aktualisiere Segment-Navigation falls aktiv
                if (currentSegmentPages.length > 0) {
                    const currentIndex = currentSegmentPages.indexOf(currentPageNum);
                    if (currentIndex >= 0) {
                        currentSegmentIndex = currentIndex;
                        const segmentName = document.getElementById('pageInfo')?.textContent.split(':')[0] || 'Segment';
                        updatePDFControlsForSegment(segmentName, currentSegmentPages);
                    }
                }
                
                // Aktualisiere Radio-Button Auswahl
                document.querySelectorAll('.page-radio').forEach(radio => {
                    const input = radio.querySelector('input[type="radio"]');
                    if (input && parseInt(input.value) === pageNum) {
                        radio.classList.add('selected');
                    } else {
                        radio.classList.remove('selected');
                    }
                });
            }
        }

        async function loadSplitResultsJSON() {
            try {
                const response = await fetch('/api/json/split_results');
                if (!response.ok) {
                    throw new Error(`Fehler beim Laden: ${response.statusText}`);
                }
                splitResultsJSON = await response.json();
            } catch (error) {
                console.error('Fehler beim Laden der Split Results:', error);
            }
        }

        async function loadParsedSegmentsJSON() {
            try {
                const response = await fetch('/api/json/parsed_segments');
                if (!response.ok) {
                    throw new Error(`Fehler beim Laden: ${response.statusText}`);
                }
                parsedSegmentsJSON = await response.json();
            } catch (error) {
                console.error('Fehler beim Laden der Parsed Segments:', error);
            }
        }

        function changeJSONSource() {
            const select = document.getElementById('jsonSourceSelect');
            currentJSONSource = select.value;
            showOnlySegment = false;
            updateContentDisplay();
        }

        function changeViewMode() {
            const select = document.getElementById('viewModeSelect');
            currentViewMode = select.value;
            updateContentDisplay();
        }

        function updateContentDisplay() {
            if (currentJSONSource === 'split_results') {
                if (showOnlySegment && currentSegmentName) {
                    if (currentViewMode === 'json') {
                        renderFilteredJSON();
                    } else {
                        renderFilteredMarkdown();
                    }
                } else {
                    if (currentViewMode === 'json') {
                        renderJSONContent();
                    } else {
                        renderMarkdownContent();
                    }
                }
            } else if (currentJSONSource === 'parsed_segments') {
                if (showOnlySegment && currentSegmentName) {
                    if (currentViewMode === 'json') {
                        renderFilteredParsedJSON();
                    } else {
                        renderFilteredParsedMarkdown();
                    }
                } else {
                    if (currentViewMode === 'json') {
                        renderParsedJSONContent();
                    } else {
                        renderParsedMarkdownContent();
                    }
                }
            }
        }

        function toggleJSONFilter() {
            showOnlySegment = !showOnlySegment;
            const filterBtn = document.getElementById('jsonFilterBtn');
            if (filterBtn) {
                filterBtn.textContent = showOnlySegment ? 'üìÑ Gesamtes JSON' : 'üìÑ Nur Segment';
            }
            
            updateContentDisplay();
        }

        function renderFilteredJSON() {
            if (!splitResultsJSON || !currentSegmentName || !currentDocument) {
                renderJSONContent();
                return;
            }

            const content = document.getElementById('jsonContent');
            const jsonViewer = document.createElement('div');
            jsonViewer.className = 'json-viewer';
            jsonViewer.style.flex = '1 1 auto';
            jsonViewer.style.minHeight = '0';
            
            // Finde das Segment im JSON
            const sourceFile = currentDocument.datei;
            let segmentData = null;
            
            // Suche in der JSON-Struktur nach dem Segment
            if (splitResultsJSON[sourceFile]) {
                segmentData = splitResultsJSON[sourceFile].find(seg => seg.name === currentSegmentName);
            }
            
            // Wenn nicht gefunden, suche in allen Dateien
            if (!segmentData) {
                for (const file in splitResultsJSON) {
                    segmentData = splitResultsJSON[file].find(seg => seg.name === currentSegmentName);
                    if (segmentData) break;
                }
            }
            
            if (segmentData) {
                const jsonString = JSON.stringify(segmentData, null, 2);
                const highlighted = highlightJSON(jsonString);
                jsonViewer.innerHTML = highlighted;
            } else {
                jsonViewer.innerHTML = '<div class="error-message">Segment nicht im JSON gefunden</div>';
            }
            
            content.innerHTML = '';
            content.appendChild(jsonViewer);
        }

        function renderFilteredMarkdown() {
            if (!parsedSegmentsJSON || !currentSegmentName || !currentDocument) {
                renderMarkdownContent();
                return;
            }

            const content = document.getElementById('jsonContent');
            const markdownViewer = document.createElement('div');
            markdownViewer.className = 'markdown-viewer';
            markdownViewer.style.flex = '1 1 auto';
            markdownViewer.style.minHeight = '0';
            markdownViewer.style.padding = '15px';
            markdownViewer.style.overflow = 'auto';
            
            // Finde das Segment im JSON
            const sourceFile = currentDocument.datei;
            let segmentData = null;
            
            if (parsedSegmentsJSON[sourceFile]) {
                segmentData = parsedSegmentsJSON[sourceFile].find(seg => seg.name === currentSegmentName);
            }
            
            if (!segmentData) {
                for (const file in parsedSegmentsJSON) {
                    segmentData = parsedSegmentsJSON[file].find(seg => seg.name === currentSegmentName);
                    if (segmentData) break;
                }
            }
            
            if (segmentData && segmentData.parsed && segmentData.parsed.markdown) {
                if (typeof marked !== 'undefined') {
                    markdownViewer.innerHTML = marked.parse(segmentData.parsed.markdown);
                } else {
                    markdownViewer.innerHTML = '<div class="error-message">Marked.js nicht geladen. Bitte Seite neu laden.</div>';
                }
            } else {
                markdownViewer.innerHTML = '<div class="error-message">Markdown f√ºr dieses Segment nicht verf√ºgbar</div>';
            }
            
            content.innerHTML = '';
            content.appendChild(markdownViewer);
        }

        function renderFilteredParsedJSON() {
            if (!parsedSegmentsJSON || !currentSegmentName || !currentDocument) {
                renderParsedJSONContent();
                return;
            }

            const content = document.getElementById('jsonContent');
            const jsonViewer = document.createElement('div');
            jsonViewer.className = 'json-viewer';
            jsonViewer.style.flex = '1 1 auto';
            jsonViewer.style.minHeight = '0';
            
            const sourceFile = currentDocument.datei;
            let segmentData = null;
            
            if (parsedSegmentsJSON[sourceFile]) {
                segmentData = parsedSegmentsJSON[sourceFile].find(seg => seg.name === currentSegmentName);
            }
            
            if (!segmentData) {
                for (const file in parsedSegmentsJSON) {
                    segmentData = parsedSegmentsJSON[file].find(seg => seg.name === currentSegmentName);
                    if (segmentData) break;
                }
            }
            
            if (segmentData) {
                const jsonString = JSON.stringify(segmentData, null, 2);
                const highlighted = highlightJSON(jsonString);
                jsonViewer.innerHTML = highlighted;
            } else {
                jsonViewer.innerHTML = '<div class="error-message">Segment nicht im JSON gefunden</div>';
            }
            
            content.innerHTML = '';
            content.appendChild(jsonViewer);
        }

        function renderFilteredParsedMarkdown() {
            renderFilteredMarkdown(); // Gleiche Funktion
        }

        function renderJSONContent() {
            if (!splitResultsJSON) {
                const content = document.getElementById('jsonContent');
                content.innerHTML = '<div class="loading">Lade Split Results...</div>';
                loadSplitResultsJSON().then(() => {
                    if (splitResultsJSON) {
                        renderJSONContent();
                    }
                });
                return;
            }

            const content = document.getElementById('jsonContent');
            const jsonViewer = document.createElement('div');
            jsonViewer.className = 'json-viewer';
            jsonViewer.style.flex = '1 1 auto';
            jsonViewer.style.minHeight = '0';
            
            const jsonString = JSON.stringify(splitResultsJSON, null, 2);
            const highlighted = highlightJSON(jsonString);
            jsonViewer.innerHTML = highlighted;
            
            content.innerHTML = '';
            content.appendChild(jsonViewer);
        }

        function renderMarkdownContent() {
            const content = document.getElementById('jsonContent');
            content.innerHTML = '<div class="info-text">W√§hlen Sie ein Segment aus, um das Markdown anzuzeigen</div>';
        }

        function renderParsedJSONContent() {
            if (!parsedSegmentsJSON) {
                const content = document.getElementById('jsonContent');
                content.innerHTML = '<div class="loading">Lade Parsed Segments...</div>';
                loadParsedSegmentsJSON().then(() => {
                    if (parsedSegmentsJSON) {
                        renderParsedJSONContent();
                    }
                });
                return;
            }

            const content = document.getElementById('jsonContent');
            const jsonViewer = document.createElement('div');
            jsonViewer.className = 'json-viewer';
            jsonViewer.style.flex = '1 1 auto';
            jsonViewer.style.minHeight = '0';
            
            const jsonString = JSON.stringify(parsedSegmentsJSON, null, 2);
            const highlighted = highlightJSON(jsonString);
            jsonViewer.innerHTML = highlighted;
            
            content.innerHTML = '';
            content.appendChild(jsonViewer);
        }

        function renderParsedMarkdownContent() {
            if (!parsedSegmentsJSON) {
                const content = document.getElementById('jsonContent');
                content.innerHTML = '<div class="loading">Lade Parsed Segments...</div>';
                loadParsedSegmentsJSON().then(() => {
                    if (parsedSegmentsJSON) {
                        renderParsedMarkdownContent();
                    }
                });
                return;
            }

            const content = document.getElementById('jsonContent');
            content.innerHTML = '<div class="info-text">W√§hlen Sie ein Segment aus, um das Markdown anzuzeigen</div>';
        }

        function highlightJSON(json) {
            // Einfaches Syntax-Highlighting f√ºr JSON
            return json
                .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function(match) {
                    let cls = 'json-number';
                    if (/^"/.test(match)) {
                        if (/:$/.test(match)) {
                            cls = 'json-key';
                        } else {
                            cls = 'json-string';
                        }
                    } else if (/true|false/.test(match)) {
                        cls = 'json-boolean';
                    } else if (/null/.test(match)) {
                        cls = 'json-null';
                    }
                    return '<span class="' + cls + '">' + escapeHtml(match) + '</span>';
                });
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        // Resize-Handle zwischen PDF und JSON
        function initResizeHandle() {
            const handle = document.getElementById('resizeHandle');
            const pdfPanel = document.getElementById('pdfPanel');
            const jsonPanel = document.getElementById('jsonPanel');
            const container = document.querySelector('.container');

            if (!handle || !pdfPanel || !jsonPanel) return;

            let isResizing = false;
            let startX = 0;
            let startPdfWidth = 0;
            let startJsonWidth = 0;

            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                handle.classList.add('active');
                startX = e.clientX;
                
                const pdfRect = pdfPanel.getBoundingClientRect();
                const jsonRect = jsonPanel.getBoundingClientRect();
                startPdfWidth = pdfRect.width;
                startJsonWidth = jsonRect.width;

                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                e.preventDefault();
            });

            function handleMouseMove(e) {
                if (!isResizing) return;

                const deltaX = e.clientX - startX;
                const newPdfWidth = startPdfWidth + deltaX;
                const newJsonWidth = startJsonWidth - deltaX;

                // Min-Breiten: 300px f√ºr beide Panels
                const minWidth = 300;
                const containerWidth = container.clientWidth;
                const availableWidth = containerWidth - 300 - 350 - 20; // Linke Spalten + Gaps

                if (newPdfWidth >= minWidth && newJsonWidth >= minWidth && 
                    newPdfWidth + newJsonWidth <= availableWidth) {
                    
                    // Setze neue Breiten mit CSS Grid (inkl. Resize-Handle)
                    const gridTemplateColumns = `300px 350px ${newPdfWidth}px 4px ${newJsonWidth}px`;
                    container.style.gridTemplateColumns = gridTemplateColumns;

                    // Aktualisiere PDF wenn es geladen ist - w√§hrend des Ziehens
                    if (currentPdfDoc) {
                        // Direktes Rendering w√§hrend des Ziehens f√ºr fl√ºssige Updates
                        requestAnimationFrame(() => {
                            if (currentPdfDoc && isResizing) {
                                renderPage();
                            }
                        });
                    }
                }
            }

            function handleMouseUp() {
                isResizing = false;
                handle.classList.remove('active');
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            }
        }

        // Navigation zwischen Ansichten
        function showView(viewName) {
            // Aktualisiere Men√º-Items
            document.querySelectorAll('.menu-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Zeige/Verstecke Ansichten
            document.getElementById('classificationView').classList.remove('active');
            document.getElementById('uploadView').classList.remove('active');
            
            if (viewName === 'classification') {
                document.getElementById('classificationView').classList.add('active');
            } else if (viewName === 'upload') {
                document.getElementById('uploadView').classList.add('active');
                // Lade alle Dateien aus dem data-Ordner
                loadFilesList();
            }
        }

        // Lade Liste aller hochgeladenen Dateien
        async function loadFilesList() {
            const filesList = document.getElementById('filesList');
            const filesListContent = document.getElementById('filesListContent');
            const uploadProgress = document.getElementById('uploadProgress');
            const uploadSuccess = document.getElementById('uploadSuccess');
            
            if (!filesListContent || !filesList) return;
            
            filesListContent.innerHTML = '<div class="loading">Lade Dateien...</div>';
            
            try {
                const response = await fetch('/api/files');
                const result = await response.json();
                
                if (result.success && result.files) {
                    if (result.files.length === 0) {
                        // Verstecke Liste wenn keine Dateien vorhanden
                        filesList.style.display = 'none';
                        return;
                    }
                    
                    // Zeige Liste wenn Dateien vorhanden
                    filesList.style.display = 'block';
                    
                    // Berechne verf√ºgbare H√∂he basierend auf sichtbaren Upload-Elementen
                    const uploadProgress = document.getElementById('uploadProgress');
                    const uploadSuccess = document.getElementById('uploadSuccess');
                    let maxHeight = '50vh';
                    if (uploadProgress && uploadProgress.style.display === 'block') {
                        maxHeight = '35vh'; // Weniger Platz wenn Upload-Status sichtbar
                    }
                    if (uploadSuccess && uploadSuccess.style.display === 'block') {
                        maxHeight = '35vh'; // Weniger Platz wenn Erfolgsmeldung sichtbar
                    }
                    
                    let html = '<div style="display: grid; gap: 10px; min-height: min-content;">';
                    result.files.forEach(file => {
                        const sizeMB = (file.size / (1024 * 1024)).toFixed(2);
                        const date = new Date(file.modified * 1000).toLocaleString('de-DE');
                        const safeFilename = file.filename.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                        html += `
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #667eea; flex-shrink: 0;">
                                <div style="flex: 1; min-width: 0;">
                                    <div style="font-weight: 500; color: #495057; margin-bottom: 4px; word-break: break-word;">üìÑ ${file.filename}</div>
                                    <div style="font-size: 12px; color: #6c757d;">
                                        Gr√∂√üe: ${sizeMB} MB ‚Ä¢ Ge√§ndert: ${date}
                                    </div>
                                </div>
                                <button onclick="deleteFile('${safeFilename}')" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; margin-left: 10px; flex-shrink: 0;">
                                    üóëÔ∏è L√∂schen
                                </button>
                            </div>
                        `;
                    });
                    html += '</div>';
                    // Stelle sicher, dass die Scrollbar-Eigenschaften erhalten bleiben
                    filesListContent.style.maxHeight = maxHeight;
                    filesListContent.style.overflowY = 'auto';
                    filesListContent.style.overflowX = 'hidden';
                    filesListContent.style.minHeight = '200px';
                    filesListContent.innerHTML = html;
                } else {
                    filesList.style.display = 'none';
                    filesListContent.innerHTML = '<div class="error-message">Fehler beim Laden der Dateien</div>';
                }
            } catch (error) {
                console.error('Fehler beim Laden der Dateiliste:', error);
                filesList.style.display = 'none';
                filesListContent.innerHTML = '<div class="error-message">Fehler beim Laden der Dateien</div>';
            }
        }

        // Verarbeite Dokumente mit parse_segments.py
        async function processDocuments() {
            const buttons = document.querySelectorAll('.refresh-btn');
            const processBtn = Array.from(buttons).find(btn => btn.textContent.includes('Dokumente Verarbeiten'));
            const processingStatus = document.getElementById('processingStatus');
            const processingStatusContent = document.getElementById('processingStatusContent');
            
            if (!processBtn) {
                alert('Button nicht gefunden');
                return;
            }
            
            // Lade Liste der PDF-Dateien die verarbeitet werden sollen
            let pdfFiles = [];
            try {
                const filesResponse = await fetch('/api/files');
                const filesResult = await filesResponse.json();
                if (filesResult.success && filesResult.files) {
                    pdfFiles = filesResult.files.map(f => f.filename);
                }
            } catch (error) {
                console.error('Fehler beim Laden der Dateien:', error);
            }
            
            if (pdfFiles.length === 0) {
                alert('Keine PDF-Dateien zum Verarbeiten gefunden. Bitte laden Sie zuerst Dateien hoch.');
                return;
            }
            
            // Deaktiviere Button w√§hrend Verarbeitung
            const originalText = processBtn.textContent;
            processBtn.disabled = true;
            processBtn.style.opacity = '0.6';
            processBtn.style.cursor = 'not-allowed';
            processBtn.textContent = '‚è≥ Verarbeitung l√§uft...';
            
            // Zeige Verarbeitungsstatus mit allen Dokumenten
            processingStatus.style.display = 'block';
            let currentIndex = 0;
            
            function updateProcessingStatus() {
                let html = '';
                pdfFiles.forEach((filename, index) => {
                    let statusClass = 'pending';
                    let statusText = '‚è≥ Wartend';
                    
                    if (index < currentIndex) {
                        statusClass = 'completed';
                        statusText = '‚úÖ Abgeschlossen';
                    } else if (index === currentIndex) {
                        statusClass = 'processing';
                        statusText = '<span class="spinner"></span> Wird verarbeitet...';
                    }
                    
                    html += `
                        <div class="document-status-item ${statusClass}">
                            <div>
                                <strong>üìÑ ${filename}</strong>
                            </div>
                            <div style="color: #6c757d; font-size: 12px;">
                                ${statusText}
                            </div>
                        </div>
                    `;
                });
                processingStatusContent.innerHTML = html;
            }
            
            // Initialisiere Status-Anzeige
            updateProcessingStatus();
            
            // Zeige Status in der Dokumentenliste
            const documentList = document.getElementById('documentList');
            documentList.innerHTML = '<li style="padding: 15px; background: #e7f0ff; border-left: 4px solid #667eea; color: #495057;">üîÑ Verarbeitung wird gestartet...</li>';
            
            try {
                const response = await fetch('/api/process', {
                    method: 'POST'
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    let parseProcessStarted = false;
                    
                    // Pr√ºfe regelm√§√üig den Status jedes Dokuments
                    const statusCheckInterval = setInterval(async () => {
                        try {
                            const statusResponse = await fetch('/api/process-status');
                            const statusResult = await statusResponse.json();
                            
                            // Aktualisiere Status f√ºr jedes Dokument basierend auf der Status-Datei
                            if (statusResult.status) {
                                // Aktualisiere Statusanzeige mit detaillierten Meldungen f√ºr beide Prozesse
                                updateProcessingStatusWithMessages(statusResult.status, statusResult);
                                
                                // Wenn Split abgeschlossen ist, starte automatisch Parse
                                if (statusResult.split_completed && !parseProcessStarted && !statusResult.parse_completed) {
                                    parseProcessStarted = true;
                                    console.log('Split abgeschlossen, starte Parse-Prozess...');
                                    
                                    try {
                                        const parseResponse = await fetch('/api/parse-documents', {
                                            method: 'POST'
                                        });
                                        const parseResult = await parseResponse.json();
                                        
                                        if (parseResponse.ok && parseResult.success) {
                                            console.log('Parse-Prozess gestartet');
                                        } else {
                                            console.error('Fehler beim Starten des Parse-Prozesses:', parseResult.error);
                                        }
                                    } catch (error) {
                                        console.error('Fehler beim Starten des Parse-Prozesses:', error);
                                    }
                                }
                            }
                            
                            if (statusResult.completed) {
                                // Beide Prozesse abgeschlossen
                                clearInterval(statusCheckInterval);
                                currentIndex = pdfFiles.length;
                                updateProcessingStatus();
                                documentList.innerHTML = '<li style="padding: 15px; background: #d4edda; border-left: 4px solid #28a745; color: #155724;">‚úÖ Verarbeitung abgeschlossen! Alle Dokumente wurden gesplittet und geparst.</li>';
                                
                                // Aktualisiere Dokumentenliste nach kurzer Verz√∂gerung
                                setTimeout(() => {
                                    loadDocuments();
                                    loadSplitResultsJSON(); // Lade split_results.json neu
                                    loadParsedSegmentsJSON(); // Lade parsed_segments.json neu
                                }, 2000);
                            }
                        } catch (error) {
                            console.error('Fehler beim Pr√ºfen des Status:', error);
                        }
                    }, 2000); // Pr√ºfe alle 2 Sekunden
                    
                    // Funktion zum Aktualisieren des Status mit detaillierten Meldungen f√ºr beide Prozesse
                    function updateProcessingStatusWithMessages(statusData, fullStatus) {
                        let html = '';
                        pdfFiles.forEach((filename, index) => {
                            const docStatus = statusData[filename] || { 
                                split_status: 'pending', 
                                split_message: 'Wartend',
                                parse_status: 'pending',
                                parse_message: ''
                            };
                            
                            // Bestimme Gesamtstatus
                            let overallStatusClass = 'pending';
                            let statusText = '';
                            
                            // Split-Status
                            if (docStatus.split_status === 'completed') {
                                statusText += '<div style="margin-bottom: 4px;"><span style="color: #28a745;">‚úÖ Split:</span> Abgeschlossen</div>';
                                if (docStatus.parse_status === 'completed') {
                                    overallStatusClass = 'completed';
                                    statusText += '<div><span style="color: #28a745;">‚úÖ Parse:</span> Abgeschlossen</div>';
                                } else if (docStatus.parse_status === 'processing') {
                                    overallStatusClass = 'processing';
                                    statusText += `<div><span class="spinner"></span> <span style="color: #667eea;">Parse:</span> ${docStatus.parse_message || 'Wird geparst...'}</div>`;
                                } else if (docStatus.parse_status === 'failed') {
                                    overallStatusClass = 'failed';
                                    statusText += `<div><span style="color: #dc3545;">‚ùå Parse:</span> ${docStatus.parse_message || 'Fehlgeschlagen'}</div>`;
                                } else {
                                    overallStatusClass = 'processing';
                                    statusText += '<div><span style="color: #ffc107;">‚è≥ Parse:</span> Wartend</div>';
                                }
                            } else if (docStatus.split_status === 'processing') {
                                overallStatusClass = 'processing';
                                statusText = `<span class="spinner"></span> <span style="color: #667eea;">Split:</span> ${docStatus.split_message || 'Wird verarbeitet...'}`;
                            } else if (docStatus.split_status === 'failed') {
                                overallStatusClass = 'failed';
                                statusText = `<span style="color: #dc3545;">‚ùå Split:</span> ${docStatus.split_message || 'Fehlgeschlagen'}`;
                            } else {
                                statusText = '<span style="color: #ffc107;">‚è≥ Split:</span> Wartend';
                            }
                            
                            html += `
                                <div class="document-status-item ${overallStatusClass}">
                                    <div>
                                        <strong>üìÑ ${filename}</strong>
                                    </div>
                                    <div style="color: #6c757d; font-size: 12px;">
                                        ${statusText}
                                    </div>
                                </div>
                            `;
                        });
                        processingStatusContent.innerHTML = html;
                    }
                    
                    // Stoppe Statuspr√ºfung nach 10 Minuten (falls etwas schief geht)
                    setTimeout(() => {
                        clearInterval(statusCheckInterval);
                        if (currentIndex < pdfFiles.length) {
                            updateProcessingStatus();
                            documentList.innerHTML = '<li style="padding: 15px; background: #fff3cd; border-left: 4px solid #ffc107; color: #856404;">‚è≥ Verarbeitung l√§uft im Hintergrund. Bitte warten Sie einige Minuten und aktualisieren Sie die Seite.</li>';
                        }
                    }, 600000); // 10 Minuten
                    
                } else {
                    processingStatus.style.display = 'none';
                    documentList.innerHTML = `<li style="padding: 15px; background: #f8d7da; border-left: 4px solid #dc3545; color: #721c24;">‚ùå Fehler: ${result.error || 'Unbekannter Fehler'}</li>`;
                }
            } catch (error) {
                processingStatus.style.display = 'none';
                documentList.innerHTML = `<li style="padding: 15px; background: #f8d7da; border-left: 4px solid #dc3545; color: #721c24;">‚ùå Fehler: ${error.message}</li>`;
            } finally {
                // Aktiviere Button wieder nach 2 Sekunden
                setTimeout(() => {
                    processBtn.disabled = false;
                    processBtn.style.opacity = '1';
                    processBtn.style.cursor = 'pointer';
                    processBtn.textContent = originalText;
                }, 2000);
            }
        }

        // Parse Dokumente mit parse_segments.py
        async function parseDocuments() {
            const parseBtn = document.querySelector('.refresh-btn[onclick="parseDocuments()"]');
            
            if (!parseBtn) {
                alert('Button nicht gefunden');
                return;
            }
            
            // Deaktiviere Button w√§hrend Verarbeitung
            const originalText = parseBtn.textContent;
            parseBtn.disabled = true;
            parseBtn.style.opacity = '0.6';
            parseBtn.style.cursor = 'not-allowed';
            parseBtn.textContent = '‚è≥ Parsing l√§uft...';
            
            // Zeige Status in der Kategorien-Liste
            const categoriesContent = document.getElementById('categoriesContent');
            const originalContent = categoriesContent.innerHTML;
            categoriesContent.innerHTML = '<div style="padding: 15px; background: #e7f0ff; border-left: 4px solid #667eea; color: #495057;">üîÑ Parsing wird gestartet...</div>';
            
            try {
                const response = await fetch('/api/parse-documents', {
                    method: 'POST'
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    categoriesContent.innerHTML = '<div style="padding: 15px; background: #d4edda; border-left: 4px solid #28a745; color: #155724;">‚úÖ Parsing gestartet! Die Verarbeitung l√§uft im Hintergrund. Bitte warten Sie einige Minuten.</div>';
                    
                    // Aktualisiere Dokumentenliste nach 10 Sekunden automatisch
                    setTimeout(() => {
                        loadDocuments();
                    }, 10000);
                } else {
                    categoriesContent.innerHTML = `<div style="padding: 15px; background: #f8d7da; border-left: 4px solid #dc3545; color: #721c24;">‚ùå Fehler: ${result.error || 'Unbekannter Fehler'}</div>`;
                }
            } catch (error) {
                categoriesContent.innerHTML = `<div style="padding: 15px; background: #f8d7da; border-left: 4px solid #dc3545; color: #721c24;">‚ùå Fehler: ${error.message}</div>`;
            } finally {
                // Aktiviere Button wieder nach 2 Sekunden
                setTimeout(() => {
                    parseBtn.disabled = false;
                    parseBtn.style.opacity = '1';
                    parseBtn.style.cursor = 'pointer';
                    parseBtn.textContent = originalText;
                }, 2000);
            }
        }

        // L√∂sche eine Datei
        async function deleteFile(filename) {
            if (!confirm(`M√∂chten Sie die Datei "${filename}" wirklich l√∂schen?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/files/${encodeURIComponent(filename)}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    // Aktualisiere Dateiliste
                    loadFilesList();
                    // Aktualisiere Dokumentenliste falls Klassifizierung aktiv ist
                    if (document.getElementById('classificationView').classList.contains('active')) {
                        loadDocuments();
                    }
                } else {
                    alert(`Fehler beim L√∂schen: ${result.error || 'Unbekannter Fehler'}`);
                }
            } catch (error) {
                alert(`Fehler beim L√∂schen: ${error.message}`);
            }
        }

        // Upload-Funktionalit√§t
        function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.style.background = '#e7f0ff';
            event.currentTarget.style.borderColor = '#667eea';
        }

        function handleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.style.background = '#f8f9fa';
            event.currentTarget.style.borderColor = '#667eea';
        }

        function handleDrop(event) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.style.background = '#f8f9fa';
            event.currentTarget.style.borderColor = '#667eea';
            
            const files = event.dataTransfer.files;
            uploadFiles(files);
        }

        function handleFileSelect(event) {
            const files = event.target.files;
            uploadFiles(files);
        }

        async function uploadFiles(files) {
            const uploadProgress = document.getElementById('uploadProgress');
            const uploadList = document.getElementById('uploadList');
            const uploadSuccess = document.getElementById('uploadSuccess');
            
            uploadProgress.style.display = 'block';
            uploadSuccess.style.display = 'none';
            uploadList.innerHTML = '';
            
            const fileArray = Array.from(files);
            let successCount = 0;
            let errorCount = 0;
            
            for (const file of fileArray) {
                if (!file.name.toLowerCase().endsWith('.pdf')) {
                    uploadList.innerHTML += `<div style="padding: 10px; margin-bottom: 5px; background: #fff3cd; border-left: 4px solid #ffc107; color: #856404;">
                        ‚ö†Ô∏è ${file.name} - Nur PDF-Dateien werden unterst√ºtzt
                    </div>`;
                    errorCount++;
                    continue;
                }
                
                const formData = new FormData();
                formData.append('file', file);
                
                uploadList.innerHTML += `<div id="status-${file.name.replace(/[^a-zA-Z0-9]/g, '_')}" style="padding: 10px; margin-bottom: 5px; background: #e7f0ff; border-left: 4px solid #667eea;">
                        üì§ ${file.name} - Wird hochgeladen...
                    </div>`;
                
                try {
                    const response = await fetch('/api/upload', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const result = await response.json();
                    
                    if (response.ok) {
                        const statusId = `status-${file.name.replace(/[^a-zA-Z0-9]/g, '_')}`;
                        document.getElementById(statusId).innerHTML = 
                            `<div style="color: #155724;">‚úÖ ${file.name} - Erfolgreich hochgeladen</div>`;
                        successCount++;
                    } else {
                        const statusId = `status-${file.name.replace(/[^a-zA-Z0-9]/g, '_')}`;
                        document.getElementById(statusId).innerHTML = 
                            `<div style="color: #721c24;">‚ùå ${file.name} - Fehler: ${result.error || 'Unbekannter Fehler'}</div>`;
                        errorCount++;
                    }
                } catch (error) {
                    const statusId = `status-${file.name.replace(/[^a-zA-Z0-9]/g, '_')}`;
                    document.getElementById(statusId).innerHTML = 
                        `<div style="color: #721c24;">‚ùå ${file.name} - Fehler: ${error.message}</div>`;
                    errorCount++;
                }
            }
            
            if (successCount > 0) {
                uploadSuccess.style.display = 'block';
                uploadSuccess.innerHTML = `<div style="background: #d4edda; border: 1px solid #c3e6cb; color: #155724; padding: 15px; border-radius: 8px;">
                    ‚úÖ ${successCount} Datei${successCount > 1 ? 'en' : ''} erfolgreich hochgeladen!${errorCount > 0 ? ` ${errorCount} Fehler.` : ''}
                </div>`;
                
                // Aktualisiere Dokumentenliste und Dateiliste nach kurzer Verz√∂gerung
                setTimeout(() => {
                    loadFilesList();
                    // Aktualisiere H√∂he der Dateiliste nach dem Laden, wenn Upload-Status sichtbar ist
                    setTimeout(() => {
                        const filesListContent = document.getElementById('filesListContent');
                        if (filesListContent) {
                            const uploadProgress = document.getElementById('uploadProgress');
                            const uploadSuccess = document.getElementById('uploadSuccess');
                            let maxHeight = '50vh';
                            if (uploadProgress && uploadProgress.style.display === 'block') {
                                maxHeight = '35vh';
                            }
                            if (uploadSuccess && uploadSuccess.style.display === 'block') {
                                maxHeight = '35vh';
                            }
                            filesListContent.style.maxHeight = maxHeight;
                        }
                    }, 200);
                    if (document.getElementById('classificationView').classList.contains('active')) {
                        loadDocuments();
                    }
                }, 1000);
            }
        }

        // Initialisiere Resize-Handle beim Laden
        document.addEventListener('DOMContentLoaded', () => {
            initResizeHandle();
        });

        // Initialisiere auch wenn DOM bereits geladen ist
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initResizeHandle);
        } else {
            initResizeHandle();
        }

        // ResizeObserver f√ºr bessere Performance bei Gr√∂√üen√§nderungen - optimiert f√ºr fl√ºssige Updates
        let pdfObserver = null;
        if (window.ResizeObserver) {
            const pdfContainer = document.getElementById('pdfContainer');
            
            pdfObserver = new ResizeObserver((entries) => {
                // Komplett deaktiviert w√§hrend Segment-Rendering
                if (isRenderingSegment) {
                    return;
                }
                
                // Nur f√ºr normale Einzel-Seiten-Ansicht
                if (currentPdfDoc && currentSegmentPages.length === 0 && !isRendering) {
                    scheduleRender();
                }
            });
            
            if (pdfContainer) {
                pdfObserver.observe(pdfContainer);
            }
        }
        
        // Funktion zum tempor√§ren Stoppen des Observers
        function pauseResizeObserver() {
            if (pdfObserver) {
                // Observer kann nicht pausiert werden, aber wir ignorieren die Events
            }
        }
        
        function resumeResizeObserver() {
            // Observer l√§uft weiter, Events werden wieder verarbeitet
        }
    </script>
</body>
</html>





